<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4 Pics 1 Word! : CICS Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a3e 0%, #2d1b69 50%, #1a1a3e 100%);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            color: #333;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 30% 30%, rgba(138, 43, 226, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 70% 70%, rgba(0, 100, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .game-container {
            background: rgba(138, 43, 226, 0.15);
            backdrop-filter: blur(15px);
            border-radius: 0;
            padding: 15px;
            box-shadow: 
                0 0 30px rgba(138, 43, 226, 0.3),
                inset 0 0 50px rgba(0, 100, 255, 0.1);
            width: 100vw;
            min-height: 100vh;
            text-align: center;
            position: relative;
            border: 1px solid rgba(138, 43, 226, 0.3);
            z-index: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            overflow-y: auto;
            overflow-x: hidden; /* Added to prevent horizontal scrolling */
            box-sizing: border-box;

        .game-header {
            margin-bottom: 10px;
            flex-shrink: 0;
            position: relative;
        }

        .game-header::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 150%;
            height: 150%;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.1) 0%, rgba(0, 100, 255, 0.1) 50%, transparent 70%);
            transform: translate(-50%, -50%);
            animation: headerBreathing 4s ease-in-out infinite;
            z-index: -1;
            border-radius: 50%;
        }

        @keyframes headerBreathing {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.3;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.6;
            }
        }

        .game-title {
            font-size: 2.5em;
            color: #ffffff;
            background: transparent;
            margin-bottom: 8px;
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
            font-family: 'Arial Black', sans-serif;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 3;
        }

        .game-title::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120%;
            height: 120%;
            background: radial-gradient(circle, rgba(222, 146, 241, 0.6) 0%, rgba(0, 100, 255, 0.4) 30%, rgba(138, 43, 226, 0.3) 60%, transparent 80%);
            transform: translate(-50%, -50%);
            animation: breathingGlow 3s ease-in-out infinite;
            z-index: -1;
            border-radius: 50%;
            filter: blur(8px);
        }

        .game-title::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 100, 255, 0.4) 0%, rgba(138, 43, 226, 0.6) 50%, transparent 70%);
            transform: translate(-50%, -50%);
            animation: breathingGlow 3s ease-in-out infinite reverse;
            z-index: -2;
            border-radius: 50%;
            filter: blur(12px);
        }

        @keyframes breathingGlow {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.6;
            }
            25% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 0.8;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            75% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 0.8;
            }
        }

        .stats::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(138, 43, 226, 0.3), transparent);
            transition: left 0.8s;
        }

        .stats:hover::before {
            left: 100%;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.25), rgba(0, 100, 255, 0.25));
            backdrop-filter: blur(20px);
            padding: 15px 25px;
            border-radius: 20px;
            margin-bottom: 10px;
            box-shadow: 
                0 10px 40px rgba(138, 43, 226, 0.3),
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 0 1px rgba(138, 43, 226, 0.4),
                0 0 20px rgba(0, 100, 255, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.4);
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            gap: 8px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            padding: 5px 10px;
            border-radius: 12px;
            background: rgba(138, 43, 226, 0.15);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 100, 255, 0.3);
        }

        .stat-item:hover {
            transform: translateY(-2px);
            background: rgba(0, 100, 255, 0.2);
            box-shadow: 0 8px 20px rgba(138, 43, 226, 0.4);
        }

        .stat-label::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: linear-gradient(45deg, #0064ff, #8a2be2);
            margin-right: 6px;
            box-shadow: 0 2px 6px rgba(138, 43, 226, 0.6);
        }

        .stat-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 5px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: 800;
            background: linear-gradient(45deg, #ffffff, #e6f2ff);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 8px rgba(255,255,255,0.5);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)) drop-shadow(0 0 8px rgba(0, 100, 255, 0.3));
        }

        .images-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 10px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
            flex-shrink: 0;
        }

        .image-container {
            width: 190px; /* Slightly increased size */
            height: 190px; /* Slightly increased size */
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            border-radius: 8px; /* Slightly rounded corners */
            transition: all 0.3s ease; /* Smooth transition for all properties */
        }

        .image-container:hover {
            box-shadow: 0 0 15px rgba(241, 134, 255, 0.8), 0 0 25px rgba(217, 103, 255, 0.6); /* Glowing background effect */
        }

        .image-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(138, 43, 226, 0.4), transparent);
            /* Removed: transition: left 0.5s; */
        }

        /* Removed: .image-container:hover::before { left: 100%; } */

        .image-container canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .word-input-section {
            margin-bottom: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            flex-shrink: 0;
        }

        .word-display {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            max-width: 100%;
            align-items: center; /* Add this to center align items */
        }

        /* Remove the problematic nth-child rules that force wrapping */
        /* .word-display .letter-box:nth-child(10n) {
            margin-right: calc(100% - 32px);
        } */

        /* Update mobile responsive to not force early wrapping */
        @media (max-width: 768px) {
            .letter-box {
                width: 25px;
                height: 25px;
                font-size: 0.9em;
            }
            
            .letter-tile {
                width: 25px;
                height: 25px;
                font-size: 0.8em;
            }
            
            .word-display {
                gap: 2px;
                /* Remove forced wrapping on mobile too */
            }
            
            .word-spacer {
                width: 15px;
                height: 25px;
                font-size: 1.2em;
            }
            
            /* Only wrap if the container is too small, not at fixed intervals */
            .word-display {
                max-width: 95vw; /* Allow nearly full width */
            }
        }

        /* For very long words, allow natural wrapping based on container width */
        .word-display {
            max-width: 90vw; /* Use most of the viewport width */
        }

        /* Remove all forced nth-child wrapping rules */
        /*
        .word-display .letter-box:nth-child(7n) {
            margin-right: calc(100% - 25px);
        }
        */

        .letter-box {
            width: 32px; /* Smaller for long words */
            height: 32px;
            border: 2px solid rgba(138, 43, 226, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em; /* Slightly smaller font */
            font-weight: 700;
            background: linear-gradient(135deg, white, #f0f4ff);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: 
                0 3px 10px rgba(138, 43, 226, 0.2),
                inset 0 1px 0 rgba(255,255,255,0.8),
                0 0 8px rgba(0, 100, 255, 0.1);
            margin: 1px;
        }

        .letter-box:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 6px 20px rgba(138, 43, 226, 0.3),
                0 0 15px rgba(0, 100, 255, 0.2);
        }

        .letter-box.filled {
            background: linear-gradient(135deg, #0064ff, #8a2be2);
            color: white;
            border-color: #0064ff;
            transform: scale(1.05);
            box-shadow: 
                0 8px 25px rgba(138, 43, 226, 0.4),
                0 0 20px rgba(0, 100, 255, 0.3);
        }

        .letter-box.correct {
            background: linear-gradient(135deg, #4169e1, #9932cc);
            border-color: #4169e1;
            animation: bounceCorrect 0.6s ease;
            box-shadow: 
                0 8px 25px rgba(65, 105, 225, 0.5),
                0 0 25px rgba(153, 50, 204, 0.4);
        }

        .letter-box.wrong {
            background: linear-gradient(135deg, #8a2be2, #4b0082);
            border-color: #8a2be2;
            animation: shakeWrong 0.6s ease;
            box-shadow: 
                0 8px 25px rgba(138, 43, 226, 0.5),
                0 0 25px rgba(75, 0, 130, 0.4);
        }

        .letter-bank {
            display: flex;
            justify-content: center;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .letter-tile {
            width: 32px; /* Smaller to match letter boxes */
            height: 32px;
            background: linear-gradient(135deg, #0064ff, #8a2be2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 4px 15px rgba(138, 43, 226, 0.3),
                inset 0 1px 0 rgba(255,255,255,0.3),
                0 0 10px rgba(0, 100, 255, 0.2);
            position: relative;
            overflow: hidden;
            margin: 1px;
        }

        .letter-tile:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 8px 20px rgba(138, 43, 226, 0.4),
                0 0 15px rgba(0, 100, 255, 0.3);
        }

        .letter-tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            /* Removed: transition: left 0.3s; */
        }

        /* Removed: .letter-tile:hover::before { left: 100%; } */

        .letter-tile {
            /* ... existing code ... */
            /* Removed: transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); */
            /* Removed: box-shadow from hover state */
        }

        /* Removed: .letter-tile:hover {
            background: linear-gradient(135deg, #4169e1, #9932cc);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 10px 25px rgba(138, 43, 226, 0.4),
                0 0 20px rgba(0, 100, 255, 0.4);
        } */

        .letter-tile:disabled {
            background: linear-gradient(135deg, #6a5acd, #483d8b);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(138, 43, 226, 0.2);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 100px;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.2);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            /* Removed: transition: left 0.5s; */
        }

        /* Removed: .btn:hover::before { left: 100%; } */

        .btn-primary {
            background: linear-gradient(135deg, #0064ff, #8a2be2);
            color: white;
            box-shadow: 
                0 6px 20px rgba(138, 43, 226, 0.3),
                0 0 15px rgba(0, 100, 255, 0.2);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #4169e1, #9932cc);
            transform: translateY(-3px);
            box-shadow: 
                0 12px 35px rgba(138, 43, 226, 0.4),
                0 0 25px rgba(0, 100, 255, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #8a2be2, #4b0082);
            color: white;
            box-shadow: 
                0 6px 20px rgba(138, 43, 226, 0.3),
                0 0 15px rgba(75, 0, 130, 0.2);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #9932cc, #6a0dad);
            transform: translateY(-3px);
            box-shadow: 
                0 12px 35px rgba(138, 43, 226, 0.4),
                0 0 25px rgba(106, 13, 173, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #4169e1, #7b68ee);
            color: white;
            box-shadow: 
                0 6px 20px rgba(65, 105, 225, 0.3),
                0 0 15px rgba(123, 104, 238, 0.2);
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #6495ed, #9370db);
            transform: translateY(-3px);
            box-shadow: 
                0 12px 35px rgba(65, 105, 225, 0.4),
                0 0 25px rgba(147, 112, 219, 0.3);
        }

        .hint-section {
            background: rgba(138, 43, 226, 0.15);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 43, 226, 0.4);
            border-radius: 15px;
            padding: 15px;
            margin: 10px auto;
            display: none;
            box-shadow: 
                0 8px 25px rgba(138, 43, 226, 0.3),
                0 0 20px rgba(0, 100, 255, 0.2);
            max-width: 500px;
            flex-shrink: 0;
        }

        .hint-section.show {
            display: block;
            animation: slideDownFade 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideDownFade {
            from { 
                opacity: 0; 
                transform: translateY(-20px) scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }

        .hint-text {
            color: rgba(255, 255, 255, 0.9);
            font-style: italic;
            margin-bottom: 5px;
            font-size: 1em;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .category-section {
            background: linear-gradient(135deg, #2d1b69 0%, #1a1a3e 50%, #4b0082 100%);
            padding: 15px;
            margin: -15px -15px 0 -15px;
            text-align: center;
            border-bottom: 2px solid rgba(138, 43, 226, 0.4);
            box-shadow: 
                0 4px 15px rgba(138, 43, 226, 0.3),
                inset 0 0 30px rgba(0, 100, 255, 0.1);
        }

        .category-badge {
            display: inline-block;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.4), rgba(0, 100, 255, 0.3));
            backdrop-filter: blur(15px);
            color: white;
            padding: 6px 16px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
            margin-bottom: 0;
            box-shadow: 
                0 6px 20px rgba(138, 43, 226, 0.3),
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 0 0 1px rgba(138, 43, 226, 0.4),
                0 0 15px rgba(0, 100, 255, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.4);
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .category-badge::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .category-badge:hover::before {
            left: 100%;
        }

        .category-badge:hover {
            transform: translateY(-1px);
            box-shadow: 
                0 8px 25px rgba(138, 43, 226, 0.4),
                0 0 20px rgba(0, 100, 255, 0.3);
        }

        .completion-screen {
            display: none;
            text-align: center;
        }

        .completion-screen.show {
            display: block;
            animation: victoryFadeIn 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes victoryFadeIn {
            from { 
                opacity: 0; 
                transform: scale(0.8) rotateY(180deg); 
            }
            to { 
                opacity: 1; 
                transform: scale(1) rotateY(0deg); 
            }
        }

        .trophy {
            font-size: 5em;
            margin-bottom: 25px;
            animation: trophySpin 3s ease-in-out infinite;
            text-shadow: 
                0 0 20px rgba(138, 43, 226, 0.6),
                0 0 30px rgba(0, 100, 255, 0.4);
            filter: drop-shadow(0 8px 16px rgba(0,0,0,0.3));
        }

        @keyframes trophySpin {
            0%, 100% { 
                transform: rotate(-15deg) scale(1); 
            }
            25% { 
                transform: rotate(15deg) scale(1.1); 
            }
            50% { 
                transform: rotate(-10deg) scale(1.05); 
            }
            75% { 
                transform: rotate(10deg) scale(1.1); 
            }
        }

        #gameScreen {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 15px;
            overflow: visible;
            animation: gameStart 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            padding-bottom: 20px;
            background: linear-gradient(135deg, #2d1b69 0%, #1a1a3e 50%, #4b0082 100%);
            margin: -5px -15px 0 -15px;
            padding: 15px 15px 20px 15px;
            border-radius: 0;
            box-shadow: 
                inset 0 0 50px rgba(138, 43, 226, 0.1),
                0 0 30px rgba(0, 100, 255, 0.1);
        }

        .sound-toggle {
            background: linear-gradient(135deg, #8a2be2, #4b0082) !important;
            box-shadow: 
                0 6px 20px rgba(138, 43, 226, 0.4),
                0 0 15px rgba(75, 0, 130, 0.3);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .sound-toggle:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 8px 20px rgba(138, 43, 226, 0.4),
                0 0 15px rgba(0, 100, 255, 0.3);
        }

        /* Apply similar hover to music toggle if it doesn't have one */
        #musicToggle:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4), 0 0 10px rgba(0, 255, 255, 0.6);
        }

        /* Combined Stats and Category Section */
        .stats-category-section {
            background: linear-gradient(135deg, #2d1b69 0%, #1a1a3e 50%, #4b0082 100%);
            padding: 20px 15px;
            margin: -15px -15px 0 -15px;
            text-align: center;
            border-bottom: 2px solid rgba(138, 43, 226, 0.4);
            box-shadow: 
                0 4px 15px rgba(138, 43, 226, 0.3),
                inset 0 0 30px rgba(0, 100, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .stats-category-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(138, 43, 226, 0.3), transparent);
            /* Removed: transition: left 0.8s; */
        }

        /* Removed: .stats-category-section:hover::before { left: 100%; } */

        .stats-category-section {
            /* ... existing code ... */
            /* Removed: overflow: hidden; */
        }

        /* Removed: .stats-category-section:hover::before { ... } */

        .stats-inline {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .stats-inline .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            padding: 8px 15px;
            border-radius: 12px;
            background: rgba(138, 43, 226, 0.2);
            backdrop-filter: blur(10px);
            /* Removed: transition: all 0.3s ease; */
            min-width: 80px;
            border: 1px solid rgba(0, 100, 255, 0.3);
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.2);
        }

        /* Removed: .stats-inline .stat-item:hover { ... } */

        /* Volume Slider Styling */
        #volumeSlider {
            -webkit-appearance: none;
            appearance: none;
            background: rgba(138, 43, 226, 0.3);
            height: 4px;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(45deg, #0064ff, #8a2be2);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(138, 43, 226, 0.6);
            transition: all 0.3s ease;
        }

        #volumeSlider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.8);
        }

        #volumeSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(45deg, #0064ff, #8a2be2);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(138, 43, 226, 0.6);
            transition: all 0.3s ease;
        }

        #volumeSlider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.8);
        }

        #volumeControl {
            transition: all 0.3s ease;
            background: rgba(138, 43, 226, 0.15) !important;
            border: 1px solid rgba(0, 100, 255, 0.3) !important;
        }

        #volumeControl:hover {
            background: rgba(0, 100, 255, 0.2) !important;
            transform: translateY(-1px);
            box-shadow: 
                0 4px 15px rgba(138, 43, 226, 0.3),
                0 0 10px rgba(0, 100, 255, 0.2);
        }

        /* Particle effect for correct answers */
        @keyframes particle {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) scale(0);
                opacity: 0;
            }
        }

        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: linear-gradient(45deg, #0064ff, #8a2be2);
            border-radius: 50%;
            pointer-events: none;
            animation: particle 1s ease-out forwards;
            box-shadow: 0 0 6px rgba(138, 43, 226, 0.6);
        }

        /* Enhanced focus states for accessibility */
        .btn:focus,
        .letter-tile:focus,
        .letter-box:focus {
            outline: 3px solid rgba(138, 43, 226, 0.6);
            outline-offset: 2px;
            box-shadow: 0 0 0 6px rgba(0, 100, 255, 0.3);
        }

        /* Loading animation for game start */
        @keyframes gameStart {
            0% {
                opacity: 0;
                transform: translateY(30px) scale(0.9);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        #gameScreen {
            animation: gameStart 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .game-title {
                font-size: 1.8em;
                letter-spacing: 1px;
            }
            
            .game-title::before,
            .game-title::after {
                width: 130%;
                height: 130%;
            }
            
            /* Keep all other mobile styles the same but update colors */
            .game-container {
                padding: 10px;
                min-height: 100vh;
            }

            .stats-category-section {
                margin: -10px -10px 0 -10px;
                padding: 15px 10px;
            }

            .stats-inline {
                gap: 10px;
                margin-top: 12px;
            }

            .stats-inline .stat-item {
                min-width: 65px;
                padding: 6px 12px;
            }

            #gameScreen {
                margin: 10px -10px 0 -10px;
                padding: 15px 10px 20px 10px;
            }

            /* Mobile adjustments for controls */
            #soundToggle, #musicToggle {
                position: static; /* Remove fixed positioning */
                margin: 10px auto; /* Center and add some margin */
                display: block; /* Ensure they take up full width */
            }

            /* Mobile music controls container */
            div[style*="top: 20px; right: 80px"] {
                top: 15px !important;
                right: 70px !important;
                gap: 6px !important;
            }

            #volumeControl {
                position: static; /* Remove fixed positioning */
                margin: 10px auto; /* Center and add some margin */
                display: block; /* Ensure it takes up full width */
                width: 80%; /* Adjust width for better mobile display */
            }

            #volumeSlider {
                width: 50px !important;
            }

            .images-grid {
                gap: 10px;
                max-width: 100%;
            }

            .image-container {
                height: 100px;
                font-size: 2em;
                border-radius: 12px;
            }

            .letter-box {
                width: 35px;
                height: 35px;
                font-size: 1.2em;
            }

            .letter-tile {
                width: 35px;
                height: 35px;
                font-size: 1em;
            }

            .action-buttons {
                flex-direction: row;
                gap: 8px;
            }

            .btn {
                min-width: 80px;
                padding: 8px 15px;
                font-size: 0.8em;
            }

            .word-input-section,
            .hint-section {
                max-width: 100%;
            }

            .category-badge {
                font-size: 0.75em;
                padding: 5px 12px;
            }

            .stat-value {
                font-size: 1.2em;
            }
        }

        /* Force word wrapping for very long words */
        /* .word-display .letter-box:nth-child(10n) {
            margin-right: calc(100% - 32px); */ /* Force wrap every 10 letters */
        /* } */

        /* Mobile adjustments for long words */
        @media (max-width: 768px) {
            .letter-box {
                width: 25px;
                height: 25px;
                font-size: 0.9em;
                gap: 2px;
            }
            
            .letter-tile {
                width: 25px;
                height: 25px;
                font-size: 0.8em;
            }
            
            .word-display {
                gap: 2px;
                /* Remove forced wrapping on mobile too */
            }
            
            .word-spacer {
                width: 15px;
                height: 25px;
                font-size: 1.2em;
            }
            
            /* Only wrap if the container is too small, not at fixed intervals */
            .word-display {
                max-width: 95vw; /* Allow nearly full width */
            }
        }

        .word-spacer {
            width: 20px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: rgba(255, 255, 255, 0.8);
            font-weight: bold;
            margin: 1px;
        }

        /* Mobile adjustments for word spacer */
        @media (max-width: 768px) {
            .word-spacer {
                width: 15px;
                height: 25px;
                font-size: 1.2em;
            }
        }

        @media (max-width: 768px) {
            .stat-item {
                flex-direction: column;
                align-items: center;
            }
        }

        /* .word-choice-container { */
        /* } */

        /* Mobile adjustments for controls */
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">4 Pics 1 Word!</h1>
            <button class="btn btn-secondary" onclick="toggleSound()" id="soundToggle" style="position: absolute; top: 10px; right: 20px; min-width: auto; padding: 8px 12px;">üîä</button>
            
            <!-- Music Controls -->
            <div style="position: absolute; top: 10px; right: 80px; display: flex; align-items: center; gap: 8px;">
                <button class="btn btn-secondary" onclick="toggleMusic()" id="musicToggle" style="min-width: auto; padding: 8px 12px;">üéµ</button>
                <!-- Volume Control -->
                <div id="volumeControl" style="display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); padding: 6px 10px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.2);">
                    <span style="color: rgba(255,255,255,0.8); font-size: 0.7em; font-weight: 600;">‚ô™</span>
                    <input type="range" id="volumeSlider" min="0" max="100" value="15" 
                           style="width: 60px; height: 4px; background: rgba(255,255,255,0.3); outline: none; border-radius: 2px; appearance: none; cursor: pointer;"
                           oninput="adjustMusicVolume(this.value)">
                    <span id="volumeDisplay" style="color: rgba(255,255,255,0.8); font-size: 0.6em; font-weight: 600; min-width: 20px;">15%</span>
                </div>
            </div>
        </div>

        <!-- Background Music Audio Elements -->
        <!-- Updated to use your actual music files -->
        <audio id="bgMusic1">
            <source src="musics/JazzMusic1.mp3" type="audio/mpeg">
        </audio>
        <audio id="bgMusic2">
            <source src="musics/JazzMusic4.mp3" type="audio/mpeg">
        </audio>
        <audio id="bgMusic3">
            <source src="musics/JazzMusic6.mp3" type="audio/mpeg">
        </audio>
        <audio id="bgMusic4">
            <source src="musics/JazzMusic10.mp3" type="audio/mpeg">
        </audio>
        <audio id="bgMusic5">
            <source src="musics/JazzMusic1.mp3" type="audio/mpeg">
        </audio>

        <div id="gameScreen">
            <!-- Combined Stats and Category Section -->
            <div class="stats-category-section">
                <div class="category-badge" id="category">Module 3: Protocols and Models</div>
                
                <div class="stats-inline">
                    <div class="stat-item">
                        <span class="stat-label">Round</span>
                        <span class="stat-value" id="round">1</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Score</span>
                        <span class="stat-value" id="score">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Hints</span>
                        <span class="stat-value" id="hintsLeft">3</span>
                    </div>
                </div>
            </div>
            
            <div class="images-grid" id="imagesGrid">
                <div class="image-container">
                    <canvas id="canvas0" width="200" height="150"></canvas>
                </div>
                <div class="image-container">
                    <canvas id="canvas1" width="200" height="150"></canvas>
                </div>
                <div class="image-container">
                    <canvas id="canvas2" width="200" height="150"></canvas>
                </div>
                <div class="image-container">
                    <canvas id="canvas3" width="200" height="150"></canvas>
                </div>
            </div>

            <div class="hint-section" id="hintSection">
                <div class="hint-text" id="hintText"></div>
            </div>

            <div class="word-input-section">
                <div class="word-display" id="wordDisplay"></div>
                <div class="letter-bank" id="letterBank"></div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="getHint()" id="hintBtn">Get Hint</button>
                <button class="btn btn-primary" onclick="clearWord()">Clear</button>
                <button class="btn btn-success" onclick="checkAnswer()">Submit</button>
            </div>
        </div>

        <div class="completion-screen" id="completionScreen">
            <div class="trophy">üèÜ</div>
            <h2>Congratulations!</h2>
            <p>You've completed all rounds!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="btn btn-primary" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        // Fixed JavaScript with proper variable declarations and music system
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = true;
        
        // Background Music System - Fixed variable declarations
        let musicEnabled = true;
        let currentMusicTrack = 0;
        let musicVolume = 0.15;
        let savedMusicTime = 0; // Added missing variable
        
        // Fixed music tracks array
        const musicTracks = ['bgMusic1', 'bgMusic2', 'bgMusic3', 'bgMusic4', 'bgMusic5'];
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const toggleBtn = document.getElementById('soundToggle');
            toggleBtn.textContent = soundEnabled ? 'üîä' : 'üîá';
            
            // Resume audio context if needed
            if (soundEnabled && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }
        
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            const toggleBtn = document.getElementById('musicToggle');
            toggleBtn.textContent = musicEnabled ? 'üéµ' : 'üîá';
            
            console.log('Music enabled:', musicEnabled);
            
            if (musicEnabled) {
                setTimeout(() => resumeBackgroundMusic(), 100);
            } else {
                pauseAllMusic();
            }
        }
        
        function playBackgroundMusic() {
            if (!musicEnabled) return;
            
            // Check if music is already playing
            if (isMusicPlaying()) {
                console.log('Music already playing, not starting new track');
                return;
            }
            
            stopAllMusic();
            
            const trackId = musicTracks[currentMusicTrack];
            const audioElement = document.getElementById(trackId);
            
            console.log('Trying to play track:', trackId);
            
            if (audioElement) {
                audioElement.volume = musicVolume;
                audioElement.currentTime = 0;
                
                audioElement.play().then(() => {
                    console.log('Successfully playing:', trackId);
                }).catch(error => {
                    console.log('Could not play music track:', trackId, error);
                    nextMusicTrack();
                });
                
                audioElement.onended = () => {
                    if (musicEnabled) {
                        console.log('Track ended, moving to next track');
                        nextMusicTrack();
                    }
                };
            } else {
                console.log('Audio element not found:', trackId);
                nextMusicTrack();
            }
        }
        
        function resumeBackgroundMusic() {
            if (!musicEnabled) return;
            
            // Check if music is already playing
            if (isMusicPlaying()) {
                console.log('Music already playing, not resuming');
                return;
            }
            
            const trackId = musicTracks[currentMusicTrack];
            const audioElement = document.getElementById(trackId);
            
            console.log('Trying to resume track:', trackId, 'from time:', savedMusicTime);
            
            if (audioElement) {
                audioElement.volume = musicVolume;
                audioElement.currentTime = savedMusicTime;
                
                audioElement.play().then(() => {
                    console.log('Successfully resumed:', trackId);
                }).catch(error => {
                    console.log('Could not resume music track:', trackId, error);
                    playBackgroundMusic();
                });
                
                audioElement.onended = () => {
                    if (musicEnabled) {
                        console.log('Resumed track ended, moving to next track');
                        savedMusicTime = 0;
                        nextMusicTrack();
                    }
                };
            } else {
                console.log('Audio element not found:', trackId);
                nextMusicTrack();
            }
        }
        
        function pauseAllMusic() {
            const currentTrackId = musicTracks[currentMusicTrack];
            const currentAudio = document.getElementById(currentTrackId);
            if (currentAudio && !currentAudio.paused) {
                savedMusicTime = currentAudio.currentTime;
                console.log('Saved music time:', savedMusicTime);
            }
            
            musicTracks.forEach(trackId => {
                const audioElement = document.getElementById(trackId);
                if (audioElement) {
                    audioElement.pause();
                }
            });
        }
        
        function nextMusicTrack() {
            currentMusicTrack = (currentMusicTrack + 1) % musicTracks.length;
            savedMusicTime = 0;
            if (musicEnabled) {
                setTimeout(() => playBackgroundMusic(), 500);
            }
        }
        
        function stopAllMusic() {
            musicTracks.forEach(trackId => {
                const audioElement = document.getElementById(trackId);
                if (audioElement) {
                    audioElement.pause();
                    audioElement.currentTime = 0;
                }
            });
        }
        
        function setMusicVolume(volume) {
            musicVolume = Math.max(0, Math.min(1, volume));
            musicTracks.forEach(trackId => {
                const audioElement = document.getElementById(trackId);
                if (audioElement) {
                    audioElement.volume = musicVolume;
                }
            });
        }
        
        function adjustMusicVolume(sliderValue) {
            const volume = sliderValue / 100;
            setMusicVolume(volume);
            
            document.getElementById('volumeDisplay').textContent = sliderValue + '%';
            
            const currentTrackId = musicTracks[currentMusicTrack];
            const currentAudio = document.getElementById(currentTrackId);
            if (currentAudio && !currentAudio.paused) {
                currentAudio.volume = musicVolume;
            }
            
            console.log('Music volume set to:', volume, '(' + sliderValue + '%)');
        }
        
        // Initialize music when page loads
        window.addEventListener('load', () => {
            console.log('Page loaded, initializing music...');
            
            // Start music only once when page loads
            if (musicEnabled) {
                setTimeout(() => playBackgroundMusic(), 1000);
            }
            
            // User interaction handler for browsers that require it
            document.addEventListener('click', () => {
                if (musicEnabled && !isMusicPlaying()) {
                    playBackgroundMusic();
                }
            }, { once: true });
            
            document.getElementById('musicToggle').addEventListener('click', () => {
                if (musicEnabled) {
                    playBackgroundMusic();
                }
            });

            // Cheat Codes / Developer Tools
            document.addEventListener('keydown', (event) => {
                // Ctrl+Shift+S to Skip Question
                if (event.ctrlKey && event.shiftKey && event.key === 'S') {
                    event.preventDefault(); // Prevent default browser action
                    skipQuestion();
                }
                // Ctrl+Shift+C to Check Correct
                if (event.ctrlKey && event.shiftKey && event.key === 'C') {
                    event.preventDefault(); // Prevent default browser action
                    checkCorrectCheat();
                }
            });
        });
        
        function isMusicPlaying() {
            const currentTrackId = musicTracks[currentMusicTrack];
            const currentAudio = document.getElementById(currentTrackId);
            return currentAudio && !currentAudio.paused;
        }
        
        // Fixed sound effect functions
        function createBeep(frequency, duration, type = 'sine') {
            if (!soundEnabled) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (error) {
                console.log('Audio not available');
            }
        }
        
        function playCorrectSound() {
            createBeep(523.25, 0.2);
            setTimeout(() => createBeep(659.25, 0.2), 100);
            setTimeout(() => createBeep(783.99, 0.3), 200);
        }
        
        function playWrongSound() {
            createBeep(220, 0.1, 'sawtooth');
            setTimeout(() => createBeep(185, 0.1, 'sawtooth'), 100);
            setTimeout(() => createBeep(150, 0.2, 'sawtooth'), 200);
        }
        
        function playClickSound() {
            createBeep(800, 0.1, 'square');
        }
        
        function playHintSound() {
            createBeep(400, 0.1);
            setTimeout(() => createBeep(500, 0.1), 50);
        }
        
        function playCompletionSound() {
            const notes = [523.25, 659.25, 783.99, 1046.5];
            notes.forEach((note, index) => {
                setTimeout(() => createBeep(note, 0.3), index * 150);
            });
        }
        
        function playNewRoundSound() {
            createBeep(659.25, 0.2);
            setTimeout(() => createBeep(783.99, 0.2), 100);
        }

        // Developer Cheat Functions
        function skipQuestion() {
            console.log("Cheat: Skipping question...");
            currentRound++;
            loadRound();
            playNewRoundSound();
        }

        function checkCorrectCheat() {
            console.log("Cheat: Marking question as correct...");
            const letterBoxes = document.querySelectorAll('.letter-box');
            
            // Fill in the correct answer
            for (let i = 0; i < currentWord.length; i++) {
                if (currentWord[i] !== ' ') {
                    selectedLetters[i] = currentWord[i];
                    const box = document.querySelector(`.letter-box[data-index="${i}"]`);
                    box.textContent = currentWord[i];
                    box.classList.add('filled');
                }
            }

            // Disable all letter tiles in the bank
            document.querySelectorAll('.letter-tile').forEach(tile => {
                tile.disabled = true;
            });
            
            playCorrectSound();
            letterBoxes.forEach(box => box.classList.add('correct'));
            score += 100 + (hintsLeft * 20); // Add score as if correctly answered

            setTimeout(() => {
                playNewRoundSound();
                currentRound++;
                loadRound();
            }, 1500);
        }

        // Game data with updated first question - add space between INTERNET and SOCIETY
        const gameData = [
            {
                category: "Module 3: Protocols and Models",
                word: "INTERNET SOCIETY",
                images: ["letter-i", "socks", "router", "futuristic-city"],
                hints: [
                    "The first letter of the alphabet",
                    "Clothing worn on feet, usually in pairs", 
                    "A networking device that forwards data packets",
                    "Advanced urban development with modern technology"
                ],
                mainHint: "Accountable for fostering the open development and evolution of internet usage globally and is abbreviated as \"ISOC\""
            },
            {
                category: "Module 3: Protocols and Models",
                word: "INTERNET ENGINEERING TASK FORCE", // Updated answer with spaces
                images: ["ietf", "soldiers", "construction", "router2"], // Updated to use your image files
                hints: [
                    "Logo of the organization",
                    "Group of people working together in organized units",
                    "Building and developing infrastructure projects", 
                    "Another networking device that forwards data packets"
                ],
                mainHint: "Focused on long-term research related to internet and TCP/IP protocols Anti-Spam Research Group (ASRG), Crypto Forum Research Group (CFRG), and Peer-to-Peer Research Group (P2PRG). Task Force Logo of the organization"
            },
            {
                category: "Module 3: Protocols and Models",
                word: "BITS", // Changed from "BITES" to "BITS"
                images: ["yummy", "dogBite", "beach", "bits"], // Updated to use your image files
                hints: [
                    "Something delicious to eat",
                    "What an aggressive dog might do",
                    "Logo of an internet organization", 
                    "Building and developing projects"
                ],
                mainHint: "When sending data physically via a medium, a physical layer PDU is utilized."
            },
            {
                category: "Module 3: Protocols and Models",
                word: "MESSAGE ENCODING", // Updated answer from APPLE to MESSAGE ENCODING
                images: ["boxes", "emerald", "typing", "inbox"], // Updated to use your image files
                hints: [
                    "Containers for storing and organizing items",
                    "A precious green gemstone",
                    "What you do when writing on a keyboard", 
                    "Where you receive electronic mail"
                ],
                mainHint: "The first step to sending a message is encoding it."
            },
            {
                category: "Module 3: Protocols and Models",
                word: "BROADCAST", // Changed from "WAVE" to "BROADCAST"
                images: ["network", "network2", "onAir", "broadcasting"], // Updated to use your image files
                hints: [
                    "Connected computer systems and devices",
                    "Another representation of connected systems",
                    "Live transmission indicator", 
                    "The act of transmitting to multiple recipients"
                ],
                mainHint: "A method of transmitting data to all devices on a network simultaneously"
            },
            {
                category: "Module 3: Protocols and Models",
                word: "PROTOCOL",
                images: ["sending", "tcp", "malefemale", "information"],
                hints: [
                    "The act of transmitting data or information to a recipient",
                    "A core networking protocol used for reliable data transmission",
                    "Represents the exchange between different entities, often male and female symbols",
                    "A collection of facts and data, often conveyed through communication"
                ],
                mainHint: "A set of rules that governs the communication between devices on a network."
            },
            {
                category: "Module 3: Protocols and Models",
                word: "DATA ACCESS",
                images: ["lock", "security", "wow", "file"],
                hints: [
                    "A common symbol for protection and restriction",
                    "Measures taken to protect data and systems",
                    "An expression of surprise or astonishment (often represented by a famous internet meme)",
                    "A collection of information stored on a computer"
                ],
                mainHint: "The process of retrieving or modifying information from a storage system."
            },
            {
                category: "Module 3: Protocols and Models",
                word: "ADDRESS",
                images: ["ip", "home", "tree", "address"],
                hints: [
                    "A unique numerical label assigned to each device connected to a computer network",
                    "A place of residence or a familiar environment",
                    "A large plant with a trunk, branches, and leaves",
                    "The location of a building or a place where someone lives or works"
                ],
                mainHint: "A unique identifier that specifies the location of a resource on a network or in memory."
            },
            {
                category: "Module 3: Protocols and Models",
                word: "ENCAPSULATION",
                images: ["lunchbox", "letter", "box", "capsule"],
                hints: [
                    "A container for carrying food",
                    "A written message or communication",
                    "A square or rectangular container",
                    "A small, soluble case containing a dose of medicine, or a small sealed container"
                ],
                mainHint: "The process of adding a header and a trailer to data as it moves down the OSI model layers."
            },
            {
                category: "Module 3: Protocols and Models",
                word: "MODEL",
                images: ["basic", "ship", "model", "http"],
                hints: [
                    "Fundamental or elementary",
                    "A large vessel for transport by sea",
                    "A representation or a simplified description of a system or theory",
                    "A common protocol used for transmitting web pages over the internet"
                ],
                mainHint: "A simplified representation of a complex system, often used to explain how something works."
            }
        ];

        let currentRound = 0;
        let score = 0;
        let hintsLeft = 3;
        let currentWord = "";
        let selectedLetters = [];
        let availableLetters = [];

        // Canvas drawing functions
        function drawEagle(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(100, 60, 40, 25, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(70, 70, 30, 15, -0.3, 0, 2 * Math.PI);
            ctx.ellipse(130, 70, 30, 15, 0.3, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(85, 55);
            ctx.lineTo(75, 60);
            ctx.lineTo(85, 65);
            ctx.closePath();
            ctx.fill();
        }

        function drawNest(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Nest base
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(100, 100, 60, 20, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // Nest sides
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3;
            for(let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(50 + i * 12, 85);
                ctx.lineTo(55 + i * 12, 100);
                ctx.stroke();
            }
            
            // Eggs
            ctx.fillStyle = '#F5F5DC';
            ctx.beginPath();
            ctx.ellipse(90, 90, 8, 12, 0, 0, 2 * Math.PI);
            ctx.ellipse(110, 88, 8, 12, 0, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawFeather(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Feather shaft
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(100, 20);
            ctx.lineTo(100, 130);
            ctx.stroke();
            
            // Feather vanes
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.ellipse(100, 70, 40, 50, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // Feather details
            ctx.strokeStyle = '#000080';
            ctx.lineWidth = 1;
            for(let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo(80, 30 + i * 8);
                ctx.lineTo(120, 30 + i * 8);
                ctx.stroke();
            }
        }

        function drawSky(canvas) {
            const ctx = canvas.getContext('2d');
            
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 150);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 200, 150);
            
            // Clouds
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(50, 40, 20, 0, 2 * Math.PI);
            ctx.arc(70, 35, 25, 0, 2 * Math.PI);
            ctx.arc(90, 40, 20, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(130, 60, 15, 0, 2 * Math.PI);
            ctx.arc(145, 55, 20, 0, 2 * Math.PI);
            ctx.arc(160, 60, 15, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawTrunk(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Trunk
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(80, 30, 40, 100);
            
            // Bark texture
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            for(let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(85, 40 + i * 15);
                ctx.lineTo(115, 45 + i * 15);
                ctx.stroke();
            }
            
            // Tree rings (cross-section view)
            ctx.strokeStyle = '#D2691E';
            ctx.lineWidth = 1;
            for(let i = 1; i < 6; i++) {
                ctx.beginPath();
                ctx.arc(100, 140, i * 8, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }

        function drawLeaves(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const colors = ['#228B22', '#32CD32', '#9ACD32', '#FFD700'];
            
            for(let i = 0; i < 20; i++) {
                const x = 20 + Math.random() * 160;
                const y = 20 + Math.random() * 110;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.ellipse(x, y, 8, 12, Math.random() * Math.PI, 0, 2 * Math.PI);
                ctx.fill();
                
                // Leaf stem
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + 8);
                ctx.stroke();
            }
        }

        function drawRoots(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Soil
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 100, 200, 50);
            
            // Roots
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3;
            
            // Main root
            ctx.beginPath();
            ctx.moveTo(100, 100);
            ctx.lineTo(100, 140);
            ctx.stroke();
            
            // Branch roots
            const branches = [
                {start: [100, 120], end: [70, 135]},
                {start: [100, 120], end: [130, 135]},
                {start: [100, 130], end: [80, 145]},
                {start: [100, 130], end: [120, 145]},
                {start: [70, 135], end: [50, 140]},
                {start: [130, 135], end: [150, 140]}
            ];
            
            branches.forEach(branch => {
                ctx.beginPath();
                ctx.moveTo(branch.start[0], branch.start[1]);
                ctx.lineTo(branch.end[0], branch.end[1]);
                ctx.stroke();
            });
        }

        function drawForest(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Sky
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, 200, 100);
            
            // Ground
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 100, 200, 50);
            
            // Trees
            const treePositions = [30, 70, 110, 150, 180];
            treePositions.forEach(x => {
                // Trunk
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 5, 80, 10, 40);
                
                // Leaves
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.arc(x, 70, 20, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // Add more drawing functions for other categories...
        function drawRed(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(0, 0, 200, 150);
            
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('RED', 100, 80);
        }

        function drawCore(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apple core
            ctx.fillStyle = '#F5F5DC';
            ctx.fillRect(90, 30, 20, 90);
            
            // Seeds
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(95, 60, 3, 5, 0, 0, 2 * Math.PI);
            ctx.ellipse(105, 70, 3, 5, 0, 0, 2 * Math.PI);
            ctx.ellipse(95, 80, 3, 5, 0, 0, 2 * Math.PI);
            ctx.ellipse(105, 90, 3, 5, 0, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawOrchard(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Sky
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, 200, 100);
            
            // Ground
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 100, 200, 50);
            
            // Apple trees in rows
            for(let row = 0; row < 2; row++) {
                for(let col = 0; col < 4; col++) {
                    const x = 30 + col * 40;
                    const y = 80 + row * 30;
                    
                    // Trunk
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x - 3, y, 6, 25);
                    
                    // Leaves
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(x, y - 5, 12, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Apples
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(x - 8, y - 8, 3, 0, 2 * Math.PI);
                    ctx.arc(x + 8, y - 3, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        function drawPie(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Pie crust
            ctx.fillStyle = '#DEB887';
            ctx.beginPath();
            ctx.arc(100, 75, 60, 0, 2 * Math.PI);
            ctx.fill();
            
            // Pie filling
            ctx.fillStyle = '#8B0000';
            ctx.beginPath();
            ctx.arc(100, 75, 50, 0, 2 * Math.PI);
            ctx.fill();
            
            // Crust pattern
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            for(let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2) / 8;
                ctx.beginPath();
                ctx.moveTo(100 + Math.cos(angle) * 45, 75 + Math.sin(angle) * 45);
                ctx.lineTo(100 + Math.cos(angle) * 55, 75 + Math.sin(angle) * 55);
                ctx.stroke();
            }
        }

        // Ocean category drawing functions
        function drawWater(canvas) {
            const ctx = canvas.getContext('2d');
            
            // Water gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 150);
            gradient.addColorStop(0, '#4169E1');
            gradient.addColorStop(1, '#000080');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 200, 150);
            
            // Water ripples
            ctx.strokeStyle = '#87CEEB';
            ctx.lineWidth = 2;
            for(let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 30 + i * 25);
                ctx.quadraticCurveTo(50, 20 + i * 25, 100, 30 + i * 25);
                ctx.quadraticCurveTo(150, 40 + i * 25, 200, 30 + i * 25);
                ctx.stroke();
            }
        }

        function drawSurf(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Water
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(0, 0, 200, 150);
            
            // Wave
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(0, 100);
            ctx.quadraticCurveTo(50, 60, 100, 80);
            ctx.quadraticCurveTo(150, 100, 200, 80);
            ctx.lineTo(200, 150);
            ctx.lineTo(0, 150);
            ctx.closePath();
            ctx.fill();
            
            // Surfboard
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(120, 90, 5, 25, -0.3, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawBeach(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Sky
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, 200, 75);
            
            // Sand
            ctx.fillStyle = '#F4A460';
            ctx.fillRect(0, 75, 200, 75);
            
            // Water edge
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.moveTo(0, 75);
            ctx.quadraticCurveTo(100, 85, 200, 75);
            ctx.lineTo(200, 90);
            ctx.quadraticCurveTo(100, 100, 0, 90);
            ctx.closePath();
            ctx.fill();
            
            // Palm tree
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(160, 50, 8, 40);
            ctx.fillStyle = '#228B22';
            for(let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6;
                ctx.beginPath();
                ctx.ellipse(164 + Math.cos(angle) * 15, 50 + Math.sin(angle) * 8, 3, 12, angle, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

    function drawMotion(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Background
        ctx.fillStyle = '#F0F8FF';
       
        ctx.fillRect(0, 0, 200, 150);
        
        // Motion lines
        ctx.strokeStyle = '#4169E1';
        ctx.lineWidth = 3;
        for(let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.moveTo(20 + i * 20, 30);
            ctx.quadraticCurveTo(30 + i * 20, 75, 40 + i * 20, 120);
            ctx.stroke();
        }
        
        // Arrows
        ctx.fillStyle = '#4169E1';
        for(let i = 0; i < 4; i++) {
            const x = 50 + i * 30;
            const y = 90;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 5, y - 10);
            ctx.lineTo(x + 5, y - 10);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Weather category drawing functions
    function drawCloud(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Sky background
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, 200, 150);
        
        // Large cloud
        ctx.fillStyle = '#DCDCDC';
        ctx.beginPath();
        ctx.arc(60, 70, 25, 0, 2 * Math.PI);
        ctx.arc(80, 60, 30, 0, 2 * Math.PI);
        ctx.arc(100, 55, 35, 0, 2 * Math.PI);
        ctx.arc(120, 60,  30, 0, 2 * Math.PI);
        ctx.arc(140, 70, 25, 0, 2 * Math.PI);
        ctx.fill();
        
        // Cloud shadow
        ctx.fillStyle = '#A9A9A9';
        ctx.beginPath();
        ctx.arc(100, 85, 50, 0, Math.PI);
        ctx.fill();
    }

    function drawDrops(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Dark sky
        ctx.fillStyle = '#696969';
        ctx.fillRect(0, 0, 200, 150);
        
        // Raindrops
        ctx.fillStyle = '#4169E1';
        for(let i = 0; i < 15; i++) {
            const x = 20 + Math.random() * 160;
            const y = 20 + Math.random() * 110;
            
            ctx.beginPath();
            ctx.arc(x, y + 5, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 2, y + 8);
            ctx.lineTo(x + 2, y + 8);
            ctx.closePath();
            ctx.fill();
        }
    }

    function drawUmbrella(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Rain background
        ctx.fillStyle = '#696969';
        ctx.fillRect(0, 0, 200,  150);
        
        // Umbrella top
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.arc(100, 70, 50, Math.PI, 0);
        ctx.fill();
        
        // Umbrella ribs
        ctx.strokeStyle = '#8B0000';
        ctx.lineWidth = 2;
        for(let i = 0; i < 7; i++) {
            const angle = Math.PI + (i * Math.PI) / 6;
            ctx.beginPath();
            ctx.moveTo(100, 70);
            ctx.lineTo(100 + Math.cos(angle) * 50, 70 + Math.sin(angle) * 50);
            ctx.stroke();
        }
        
        // Handle
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(100, 70);
        ctx.lineTo(100,  120);
        ctx.stroke();
        
        // Handle curve
        ctx.beginPath();
        ctx.arc(105, 120, 5, Math.PI, 0);
        ctx.stroke();
    }

    function drawPuddle(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Ground
        ctx.fillStyle = '#696969';
        ctx.fillRect(0, 0, 200, 150);
        
        // Puddle
        ctx.fillStyle = '#4169E1';
        ctx.beginPath();
        ctx.ellipse(100, 100, 60, 20, 0, 0, 2 * Math.PI);
        ctx.fill();
        
        // Ripples
        ctx.strokeStyle = '#87CEEB';
        ctx.lineWidth = 2;
        for(let i = 1; i < 4; i++) {
            ctx.beginPath();
            ctx.ellipse(100, 100, 20 * i, 7 * i, 0, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        // Reflection
        ctx.fillStyle = 'rgba(135, 206, 235, 0.3)';
        ctx.beginPath();
        ctx.ellipse(100, 100, 40, 15, 0, 0, 2 * Math.PI);
        ctx.fill();
    }

    // Add new image loading functions for the first question
    function loadLetterI(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            // Fallback if image doesn't load
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('I', canvas.width/2, canvas.height/2 + 15);
        };
        img.src = 'letter-i.png'; // PUT YOUR LETTER-I IMAGE HERE
    }

    function loadSocks(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            // Fallback if image doesn't load
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SOCKS', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'socks.png'; // PUT YOUR SOCKS IMAGE HERE
    }

    function loadRouter(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            // Fallback if image doesn't load
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ROUTER', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'router.png'; // PUT YOUR ROUTER IMAGE HERE
    }

    function loadFuturisticCity(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            // Fallback if image doesn't load
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('FUTURISTIC', canvas.width/2, canvas.height/2 - 8);
            ctx.fillText('CITY', canvas.width/2, canvas.height/2 + 12);
        };
        img.src = 'futuristic city.png'; // PUT YOUR FUTURISTIC CITY IMAGE HERE
    }

    // New image loading functions for question 2
    function loadIETF(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('IETF', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/IETF.png';
    }

    function loadSoldiers(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SOLDIERS', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/soldiers.png';
    }

    function loadConstruction(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CONSTRUCTION', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/construction.png';
    }

    function loadRouter2(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ROUTER', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/router2.png';
    }

    function loadYummy(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('YUMMY', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/yummy.png';
    }

    function loadDogBite(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('DOG BITE', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/dogBite.png';
    }

    // Add the missing image loading functions for question 4 (add them after the existing image functions):

    function loadBoxes(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BOXES', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/boxes.png';
    }

    function loadEmerald(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('EMERALD', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/emerald.png';
    }

    function loadTyping(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TYPING', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/typing.png';
    }

    function loadInbox(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('INBOX', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/inbox.png';
    }

    // New image loading functions for question 5
    function loadNetwork(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('NETWORK', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/network.png';
    }

    function loadNetwork2(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('NETWORK2', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/network2.png';
    }

    function loadOnAir(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ON AIR', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/onAir.png';
    }

    function loadBroadcasting(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BROADCASTING', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/broadcasting.png';
    }

    // Add the missing image loading functions for question 3:

    function loadBeach(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BEACH', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/beach.png';
    }

    function loadBits(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BITS', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/bits.png';
    }

    function loadSending(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SENDING', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/sending.png';
    }

    function loadTcp(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TCP', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/tcp.png';
    }

    function loadMaleFemale(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('MALEFEMALE', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/malefemale.png';
    }

    function loadInformation(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('INFORMATION', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/information.png';
    }

    // New image loading functions for question 7
    function loadLock(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LOCK', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/lock.png';
    }

    function loadSecurity(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SECURITY', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/security.png';
    }

    function loadWow(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('WOW', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/wow.png';
    }

    function loadFile(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('FILE', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/file.png';
    }

    // New image loading functions for question 8
    function loadIp(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('IP', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/ip.png';
    }

    function loadHome(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('HOME', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/home.png';
    }

    function loadTree(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TREE', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/tree.png';
    }

    function loadAddress(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ADDRESS', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/address.png';
    }

    // New image loading functions for question 9
    function loadLunchbox(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LUNCHBOX', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/lunchbox.png';
    }

    function loadLetter(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LETTER', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/letter.png';
    }

    function loadBox(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BOX', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/box.png';
    }

    function loadCapsule(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CAPSULE', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/capsule.png';
    }

    // New image loading functions for question 10
    function loadBasic(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BASIC', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/basic.png';
    }

    function loadShip(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SHIP', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/ship.png';
    }

    function loadModel(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('MODEL', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/model.png';
    }

    function loadHttp(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.onload = function() {
            const aspectRatio = img.width / img.height;
            let drawWidth = canvas.width;
            let drawHeight = canvas.height;
            let offsetX = 0;
            let offsetY = 0;

            if (canvas.width / canvas.height > aspectRatio) {
                drawWidth = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawWidth) / 2;
            } else {
                drawHeight = canvas.width / aspectRatio;
                offsetY = (canvas.height - drawHeight) / 2;
            }
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        img.onerror = function() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('HTTP', canvas.width/2, canvas.height/2 + 8);
        };
        img.src = 'images/http.png';
    }

    // Updated drawing functions mapping
    const drawingFunctions = {
        "letter-i": loadLetterI,
        "socks": loadSocks,
        "router": loadRouter,
        "futuristic-city": loadFuturisticCity,
        "ietf": loadIETF,
        "soldiers": loadSoldiers,
        "construction": loadConstruction,
        "router2": loadRouter2,
        "yummy": loadYummy,
        "dogBite": loadDogBite,
        "beach": loadBeach,
        "bits": loadBits,
        "boxes": loadBoxes,
        "emerald": loadEmerald,
        "typing": loadTyping,
        "inbox": loadInbox,
        "network": loadNetwork,
        "network2": loadNetwork2,
        "onAir": loadOnAir,
        "broadcasting": loadBroadcasting,
        "sending": loadSending,
        "tcp": loadTcp,
        "malefemale": loadMaleFemale,
        "information": loadInformation,
        "lock": loadLock,
        "security": loadSecurity,
        "wow": loadWow,
        "file": loadFile,
        "ip": loadIp,
        "home": loadHome,
        "tree": loadTree,
        "address": loadAddress,
        "lunchbox": loadLunchbox,
        "letter": loadLetter,
        "box": loadBox,
        "capsule": loadCapsule,
        "basic": loadBasic,
        "ship": loadShip,
        "model": loadModel,
        "http": loadHttp,
        eagle: drawEagle,
        nest: drawNest,
        feather: drawFeather,
        sky: drawSky,
        trunk: drawTrunk,
        leaves: drawLeaves,
        roots: drawRoots,
        forest: drawForest,
        red: drawRed,
        core: drawCore,
        orchard: drawOrchard,
        pie: drawPie,
        water: drawWater,
        surf: drawSurf,
        puddle: drawPuddle,
        motion: drawMotion,
        cloud: drawCloud,
        drops: drawDrops,
        umbrella: drawUmbrella
    };

    function initGame() {
        currentRound = 0;
        score = 0;
        hintsLeft = 3;
        loadRound();
    }

    function loadRound() {
        if (currentRound >= gameData.length) {
            showCompletion();
            return;
        }

        const round = gameData[currentRound];
        currentWord = round.word;
        
        // Update UI
        document.getElementById('round').textContent = currentRound + 1;
        document.getElementById('category').textContent = round.category;
        document.getElementById('hintSection').classList.remove('show');
        
        // REMOVE THIS LINE - it's causing music to restart
        // playBackgroundMusic();
        
        // Draw images
        round.images.forEach((imageType, index) => {
            const canvas = document.getElementById(`canvas${index}`);
            if (drawingFunctions[imageType]) {
                drawingFunctions[imageType](canvas);
            }
        });
        
        // Setup word display
        setupWordDisplay();
        setupLetterBank();
        updateStats();
    }

    // Updated setupWordDisplay function to handle spaces
    function setupWordDisplay() {
        const wordDisplay = document.getElementById('wordDisplay');
        wordDisplay.innerHTML = '';
        selectedLetters = new Array(currentWord.length).fill('');
        
        for (let i = 0; i < currentWord.length; i++) {
            if (currentWord[i] === ' ') {
                // Create a space divider for spaces in the word
                const spacer = document.createElement('div');
                spacer.className = 'word-spacer';
                spacer.style.width = '20px';
                spacer.style.height = '32px';
                spacer.style.display = 'flex';
                spacer.style.alignItems = 'center';
                spacer.style.justifyContent = 'center';
                spacer.style.fontSize = '1.5em';
                spacer.style.color = 'rgba(255, 255, 255, 0.8)';
                spacer.style.fontWeight = 'bold';
                spacer.textContent = '‚Ä¢'; // Visual separator
                wordDisplay.appendChild(spacer);
                selectedLetters[i] = ' '; // Mark space as filled
            } else {
                const letterBox = document.createElement('div');
                letterBox.className = 'letter-box';
                letterBox.dataset.index = i;
                letterBox.onclick = () => removeLetter(i);
                wordDisplay.appendChild(letterBox);
            }
        }
    }

    // Updated setupLetterBank function to exclude spaces from available letters
    function setupLetterBank() {
        const letterBank = document.getElementById('letterBank');
        letterBank.innerHTML = '';
        
        // Get letters from answer (excluding spaces) plus some random ones
        const answerLetters = currentWord.split('').filter(char => char !== ' ');
        const uniqueAnswerLetters = [...new Set(answerLetters)]; // Remove duplicates for random letter selection
        
        // For long words like INTERNET SOCIETY, add fewer random letters
        const randomLetterCount = answerLetters.length > 10 ? 3 : 6;
        const randomLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')
            .filter(letter => !uniqueAnswerLetters.includes(letter))
            .sort(() => Math.random() - 0.5)
            .slice(0, randomLetterCount);
        
        availableLetters = [...answerLetters, ...randomLetters]
            .sort(() => Math.random() - 0.5);
        
        availableLetters.forEach((letter, index) => {
            const tile = document.createElement('button');
            tile.className = 'letter-tile';
            tile.textContent = letter;
            tile.dataset.index = index;
            tile.onclick = () => selectLetter(index);
            letterBank.appendChild(tile);
        });
    }

    function selectLetter(tileIndex) {
        const tile = document.querySelector(`.letter-tile[data-index="${tileIndex}"]`);
        if (tile.disabled) return;
        
        playClickSound(); // Add sound effect
        
        const letter = availableLetters[tileIndex];
        // Find the next empty letter box (skip spaces)
        const emptyIndex = selectedLetters.findIndex((l, index) => l === '' && currentWord[index] !== ' ');
        
        if (emptyIndex !== -1) {
            selectedLetters[emptyIndex] = letter;
            tile.disabled = true;
            
            const letterBox = document.querySelector(`.letter-box[data-index="${emptyIndex}"]`);
            letterBox.textContent = letter;
            letterBox.classList.add('filled');
        }
    }

    // Updated removeLetter function to handle spaces
    function removeLetter(boxIndex) {
        // Don't allow removing spaces
        if (currentWord[boxIndex] === ' ') return;
        
        const letter = selectedLetters[boxIndex];
        if (!letter) return;
        
        playClickSound();
        
        selectedLetters[boxIndex] = '';
        
        const letterBox = document.querySelector(`.letter-box[data-index="${boxIndex}"]`);
        letterBox.textContent = '';
        letterBox.classList.remove('filled', 'correct', 'wrong');
        
        // Fixed tile re-enabling logic
        const tiles = document.querySelectorAll('.letter-tile');
        for (let i = 0; i < tiles.length; i++) {
            const tile = tiles[i];
            if (tile.textContent === letter && tile.disabled) {
                tile.disabled = false;
                break; // Only re-enable the first matching disabled tile
            }
        }
    }

    // Updated clearWord function to preserve spaces
    function clearWord() {
        playClickSound(); // Add sound effect
        
        // Clear only non-space positions
        for (let i = 0; i < selectedLetters.length; i++) {
            if (currentWord[i] !== ' ') {
                selectedLetters[i] = '';
            }
        }
        
        document.querySelectorAll('.letter-box').forEach(box => {
            box.textContent = '';
            box.classList.remove('filled', 'correct', 'wrong');
        });
        document.querySelectorAll('.letter-tile').forEach(tile => {
            tile.disabled = false;
        });
    }

    // Updated checkAnswer function to handle spaces properly
    function checkAnswer() {
        // Check if all letter positions (excluding spaces) are filled
        const hasEmptyLetters = selectedLetters.some((letter, index) => 
            currentWord[index] !== ' ' && letter === ''
        );
        
        if (hasEmptyLetters) {
            alert('Please fill in all letters!');
            return;
        }
        
        const guess = selectedLetters.join('');
        const letterBoxes = document.querySelectorAll('.letter-box');
        
        if (guess === currentWord) {
            // Correct answer
            playCorrectSound(); // Add sound effect
            letterBoxes.forEach(box => box.classList.add('correct'));
            score += 100 + (hintsLeft * 20); // Bonus for unused hints
            
            setTimeout(() => {
                playNewRoundSound(); // Sound for new round
                currentRound++;
                loadRound();
            }, 1500);
        } else {
            // Wrong answer
            playWrongSound(); // Add sound effect
            letterBoxes.forEach(box => box.classList.add('wrong'));
            
            setTimeout(() => {
                letterBoxes.forEach(box => box.classList.remove('wrong'));
            }, 500);
        }
        
        updateStats();
    }

    function getHint() {
        const hintSection = document.getElementById('hintSection');
        if (hintsLeft <= 0 || hintSection.classList.contains('show')) {
        if (hintsLeft <= 0) {
            alert('No hints remaining!');
            } else if (hintSection.classList.contains('show')) {
                // Hint already shown, do not deduct again
                console.log("Hint already displayed, not deducting hint again.");
            }
            return;
        }
        
        playHintSound(); // Add sound effect
        
        const round = gameData[currentRound];
        const hintText = document.getElementById('hintText');
        
        hintText.textContent = round.mainHint;
        hintSection.classList.add('show');
        
        hintsLeft--;
        updateStats();
        
        if (hintsLeft <= 0) {
            document.getElementById('hintBtn').disabled = true;
        }
    }

    function showImageHint(imageIndex) {
        playHintSound(); // Add sound effect
        
        const round = gameData[currentRound];
        if (round.hints[imageIndex]) {
            alert(round.hints[imageIndex]);
        }
    }

    function updateStats() {
        document.getElementById('score').textContent = score;
        document.getElementById('hintsLeft').textContent = hintsLeft;
    }

    function showCompletion() {
        playCompletionSound(); // Add victory sound
        
        document.getElementById('gameScreen').style.display = 'none';
        document.getElementById('completionScreen').classList.add('show');
        document.getElementById('finalScore').textContent = score;
    }

    function restartGame() {
        playClickSound(); // Add sound effect
        
        document.getElementById('gameScreen').style.display = 'block';
        document.getElementById('completionScreen').classList.remove('show');
        document.getElementById('hintBtn').disabled = false;
        initGame();
        loadRound(); // Add this line to redraw images on restart
    }

    // Start the game
    initGame();
    </script>
</body>
</html>